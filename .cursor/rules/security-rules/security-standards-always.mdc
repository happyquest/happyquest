---
description: 
globs: 
alwaysApply: false
---
# ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£åŸºæº–ãƒ«ãƒ¼ãƒ«

## ğŸ” æ©Ÿå¯†æƒ…å ±ç®¡ç†

### 1. ç’°å¢ƒå¤‰æ•°ã«ã‚ˆã‚‹ç®¡ç†
```python
# âœ… æ­£ã—ã„æ–¹æ³•
import os
from dotenv import load_dotenv

load_dotenv()

API_KEY = os.getenv('OPENAI_API_KEY')
DATABASE_URL = os.getenv('DATABASE_URL')
SECRET_KEY = os.getenv('SECRET_KEY')

if not API_KEY:
    raise ValueError("OPENAI_API_KEY environment variable is required")
```

```bash
# .env ãƒ•ã‚¡ã‚¤ãƒ«ä¾‹ï¼ˆ.gitignoreã«è¿½åŠ å¿…é ˆï¼‰
OPENAI_API_KEY=sk-proj-xxxxxxxxxxxxx
DATABASE_URL=postgresql://user:pass@localhost:5432/db
SECRET_KEY=your-secret-key-here
GITHUB_TOKEN=ghp_xxxxxxxxxxxx
```

### 2. ç¦æ­¢äº‹é …
```python
# âŒ çµ¶å¯¾ç¦æ­¢ - ãƒãƒ¼ãƒ‰ã‚³ãƒ¼ãƒ‰
API_KEY = "sk-proj-1234567890abcdef"  # çµ¶å¯¾NG
DATABASE_PASSWORD = "mypassword123"   # çµ¶å¯¾NG

# âŒ çµ¶å¯¾ç¦æ­¢ - ãƒ­ã‚°å‡ºåŠ›
logger.info(f"API Key: {api_key}")    # çµ¶å¯¾NG
print(f"Password: {password}")        # çµ¶å¯¾NG

# âŒ çµ¶å¯¾ç¦æ­¢ - ã‚³ãƒ¡ãƒ³ãƒˆå†…
# API_KEY = "sk-proj-real-key-here"   # çµ¶å¯¾NG
```

## ğŸ›¡ï¸ å…¥åŠ›å€¤æ¤œè¨¼

### 1. SQLã‚¤ãƒ³ã‚¸ã‚§ã‚¯ã‚·ãƒ§ãƒ³å¯¾ç­–
```python
# âœ… æ­£ã—ã„æ–¹æ³• - ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿åŒ–ã‚¯ã‚¨ãƒª
def get_user_by_email(email: str):
    query = "SELECT * FROM users WHERE email = %s"
    cursor.execute(query, (email,))
    return cursor.fetchone()

# âŒ å±é™º - æ–‡å­—åˆ—çµåˆ
def get_user_by_email_bad(email: str):
    query = f"SELECT * FROM users WHERE email = '{email}'"  # SQLã‚¤ãƒ³ã‚¸ã‚§ã‚¯ã‚·ãƒ§ãƒ³è„†å¼±æ€§
    cursor.execute(query)
```

### 2. XSSå¯¾ç­–
```python
# âœ… æ­£ã—ã„æ–¹æ³• - ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—å‡¦ç†
from html import escape
from markupsafe import Markup

def render_user_content(content: str):
    escaped_content = escape(content)
    return Markup(escaped_content)

# âŒ å±é™º - ç”Ÿã®å‡ºåŠ›
def render_user_content_bad(content: str):
    return content  # XSSè„†å¼±æ€§
```

### 3. å…¥åŠ›å€¤ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³
```python
from pydantic import BaseModel, EmailStr, validator
import re

class UserRegistration(BaseModel):
    email: EmailStr
    password: str
    username: str
    
    @validator('password')
    def validate_password(cls, v):
        if len(v) < 8:
            raise ValueError('Password must be at least 8 characters')
        if not re.search(r'[A-Z]', v):
            raise ValueError('Password must contain uppercase letter')
        if not re.search(r'[a-z]', v):
            raise ValueError('Password must contain lowercase letter')
        if not re.search(r'\d', v):
            raise ValueError('Password must contain digit')
        return v
    
    @validator('username')
    def validate_username(cls, v):
        if not re.match(r'^[a-zA-Z0-9_]{3,20}$', v):
            raise ValueError('Username must be 3-20 alphanumeric characters')
        return v
```

## ğŸ”’ èªè¨¼ãƒ»èªå¯

### 1. JWTå®Ÿè£…
```python
import jwt
from datetime import datetime, timedelta
from typing import Optional

class JWTManager:
    def __init__(self, secret_key: str):
        self.secret_key = secret_key
        self.algorithm = 'HS256'
    
    def create_token(self, user_id: int, expires_delta: Optional[timedelta] = None):
        if expires_delta:
            expire = datetime.utcnow() + expires_delta
        else:
            expire = datetime.utcnow() + timedelta(hours=24)
        
        payload = {
            'user_id': user_id,
            'exp': expire,
            'iat': datetime.utcnow()
        }
        
        return jwt.encode(payload, self.secret_key, algorithm=self.algorithm)
    
    def verify_token(self, token: str) -> Optional[dict]:
        try:
            payload = jwt.decode(token, self.secret_key, algorithms=[self.algorithm])
            return payload
        except jwt.ExpiredSignatureError:
            return None
        except jwt.InvalidTokenError:
            return None
```

### 2. ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãƒãƒƒã‚·ãƒ¥åŒ–
```python
import bcrypt
from typing import str

class PasswordManager:
    @staticmethod
    def hash_password(password: str) -> str:
        """ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã‚’ãƒãƒƒã‚·ãƒ¥åŒ–"""
        salt = bcrypt.gensalt()
        hashed = bcrypt.hashpw(password.encode('utf-8'), salt)
        return hashed.decode('utf-8')
    
    @staticmethod
    def verify_password(password: str, hashed: str) -> bool:
        """ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã‚’æ¤œè¨¼"""
        return bcrypt.checkpw(password.encode('utf-8'), hashed.encode('utf-8'))

# âŒ å±é™º - å¹³æ–‡ä¿å­˜
def store_password_bad(password: str):
    return password  # çµ¶å¯¾NG

# âŒ å±é™º - å¼±ã„ãƒãƒƒã‚·ãƒ¥
import hashlib
def weak_hash(password: str):
    return hashlib.md5(password.encode()).hexdigest()  # è„†å¼±
```

## ğŸŒ API ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£

### 1. ãƒ¬ãƒ¼ãƒˆåˆ¶é™
```python
from flask_limiter import Limiter
from flask_limiter.util import get_remote_address

limiter = Limiter(
    app,
    key_func=get_remote_address,
    default_limits=["200 per day", "50 per hour"]
)

@app.route('/api/login', methods=['POST'])
@limiter.limit("5 per minute")
def login():
    # ãƒ­ã‚°ã‚¤ãƒ³å‡¦ç†
    pass
```

### 2. CORSè¨­å®š
```python
from flask_cors import CORS

# âœ… æ­£ã—ã„æ–¹æ³• - åˆ¶é™çš„ãªCORS
CORS(app, origins=[
    "https://yourdomain.com",
    "https://app.yourdomain.com"
])

# âŒ å±é™º - å…¨è¨±å¯
CORS(app, origins="*")  # æœ¬ç•ªç’°å¢ƒã§ã¯å±é™º
```

### 3. HTTPSãƒªãƒ€ã‚¤ãƒ¬ã‚¯ãƒˆ
```python
from flask_talisman import Talisman

# HTTPSå¼·åˆ¶ã¨ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒ˜ãƒƒãƒ€ãƒ¼
Talisman(app, force_https=True)

@app.before_request
def force_https():
    if not request.is_secure and app.env != 'development':
        return redirect(request.url.replace('http://', 'https://'))
```

## ğŸ” ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã‚¹ã‚­ãƒ£ãƒ³

### 1. è‡ªå‹•ã‚¹ã‚­ãƒ£ãƒ³ãƒ„ãƒ¼ãƒ«
```bash
# Python ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã‚¹ã‚­ãƒ£ãƒ³
bandit -r src/                    # ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£è„†å¼±æ€§ã‚¹ã‚­ãƒ£ãƒ³
safety check                     # ä¾å­˜é–¢ä¿‚è„†å¼±æ€§ãƒã‚§ãƒƒã‚¯
pip-audit                        # ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸è„†å¼±æ€§ç›£æŸ»

# Node.js ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã‚¹ã‚­ãƒ£ãƒ³
npm audit                        # ä¾å­˜é–¢ä¿‚è„†å¼±æ€§ãƒã‚§ãƒƒã‚¯
npm audit fix                    # è‡ªå‹•ä¿®æ­£
yarn audit                       # Yarnç‰ˆç›£æŸ»
```

### 2. GitHub Actionsçµ±åˆ
```yaml
name: Security Scan

on: [push, pull_request]

jobs:
  security:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      
      - name: Python Security Scan
        run: |
          pip install bandit safety
          bandit -r src/ -f json -o bandit-report.json
          safety check --json --output safety-report.json
          
      - name: Node.js Security Scan
        run: |
          npm audit --audit-level moderate
          
      - name: Upload Security Reports
        uses: actions/upload-artifact@v3
        with:
          name: security-reports
          path: |
            bandit-report.json
            safety-report.json
```

## ğŸ—„ï¸ ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£

### 1. æ¥ç¶šã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£
```python
# âœ… æ­£ã—ã„æ–¹æ³• - SSLæ¥ç¶š
DATABASE_URL = "postgresql://user:pass@host:5432/db?sslmode=require"

# æ¥ç¶šãƒ—ãƒ¼ãƒ«è¨­å®š
from sqlalchemy import create_engine
from sqlalchemy.pool import QueuePool

engine = create_engine(
    DATABASE_URL,
    poolclass=QueuePool,
    pool_size=10,
    max_overflow=20,
    pool_pre_ping=True,
    connect_args={
        "sslmode": "require",
        "sslcert": "client-cert.pem",
        "sslkey": "client-key.pem",
        "sslrootcert": "ca-cert.pem"
    }
)
```

### 2. ãƒ‡ãƒ¼ã‚¿æš—å·åŒ–
```python
from cryptography.fernet import Fernet

class DataEncryption:
    def __init__(self, key: bytes):
        self.cipher = Fernet(key)
    
    def encrypt(self, data: str) -> str:
        """ãƒ‡ãƒ¼ã‚¿ã‚’æš—å·åŒ–"""
        return self.cipher.encrypt(data.encode()).decode()
    
    def decrypt(self, encrypted_data: str) -> str:
        """ãƒ‡ãƒ¼ã‚¿ã‚’å¾©å·åŒ–"""
        return self.cipher.decrypt(encrypted_data.encode()).decode()

# æš—å·åŒ–ã‚­ãƒ¼ã®ç”Ÿæˆï¼ˆä¸€åº¦ã ã‘å®Ÿè¡Œï¼‰
# key = Fernet.generate_key()
```

## ğŸš¨ ã‚¤ãƒ³ã‚·ãƒ‡ãƒ³ãƒˆå¯¾å¿œ

### 1. ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒ­ã‚°
```python
import logging
from datetime import datetime

security_logger = logging.getLogger('security')
security_handler = logging.FileHandler('security.log')
security_formatter = logging.Formatter(
    '%(asctime)s - %(levelname)s - %(message)s'
)
security_handler.setFormatter(security_formatter)
security_logger.addHandler(security_handler)

def log_security_event(event_type: str, user_id: int, details: dict):
    """ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã‚¤ãƒ™ãƒ³ãƒˆã‚’ãƒ­ã‚°è¨˜éŒ²"""
    security_logger.warning(
        f"SECURITY_EVENT: {event_type} - User: {user_id} - Details: {details}"
    )

# ä½¿ç”¨ä¾‹
log_security_event("FAILED_LOGIN", user_id=123, details={
    "ip_address": "192.168.1.100",
    "user_agent": "Mozilla/5.0...",
    "attempt_count": 3
})
```

### 2. ç•°å¸¸æ¤œçŸ¥
```python
from collections import defaultdict
from datetime import datetime, timedelta

class SecurityMonitor:
    def __init__(self):
        self.failed_attempts = defaultdict(list)
        self.max_attempts = 5
        self.lockout_duration = timedelta(minutes=15)
    
    def record_failed_login(self, ip_address: str):
        """ãƒ­ã‚°ã‚¤ãƒ³å¤±æ•—ã‚’è¨˜éŒ²"""
        now = datetime.utcnow()
        self.failed_attempts[ip_address].append(now)
        
        # å¤ã„è¨˜éŒ²ã‚’å‰Šé™¤
        cutoff = now - self.lockout_duration
        self.failed_attempts[ip_address] = [
            attempt for attempt in self.failed_attempts[ip_address]
            if attempt > cutoff
        ]
        
        # é–¾å€¤ãƒã‚§ãƒƒã‚¯
        if len(self.failed_attempts[ip_address]) >= self.max_attempts:
            self.trigger_security_alert(ip_address)
    
    def trigger_security_alert(self, ip_address: str):
        """ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã‚¢ãƒ©ãƒ¼ãƒˆã‚’ç™ºç”Ÿ"""
        log_security_event("BRUTE_FORCE_DETECTED", 0, {
            "ip_address": ip_address,
            "attempt_count": len(self.failed_attempts[ip_address])
        })
```

## ğŸ“‹ ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒã‚§ãƒƒã‚¯ãƒªã‚¹ãƒˆ

### é–‹ç™ºæ™‚ãƒã‚§ãƒƒã‚¯
- [ ] **æ©Ÿå¯†æƒ…å ±**: ãƒãƒ¼ãƒ‰ã‚³ãƒ¼ãƒ‰ã•ã‚ŒãŸç§˜å¯†æƒ…å ±ãŒãªã„ã‹
- [ ] **å…¥åŠ›æ¤œè¨¼**: å…¨ã¦ã®å…¥åŠ›å€¤ãŒé©åˆ‡ã«æ¤œè¨¼ã•ã‚Œã¦ã„ã‚‹ã‹
- [ ] **å‡ºåŠ›ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—**: XSSå¯¾ç­–ãŒå®Ÿè£…ã•ã‚Œã¦ã„ã‚‹ã‹
- [ ] **SQLã‚¤ãƒ³ã‚¸ã‚§ã‚¯ã‚·ãƒ§ãƒ³**: ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿åŒ–ã‚¯ã‚¨ãƒªã‚’ä½¿ç”¨ã—ã¦ã„ã‚‹ã‹
- [ ] **èªè¨¼**: é©åˆ‡ãªèªè¨¼ãƒ¡ã‚«ãƒ‹ã‚ºãƒ ãŒå®Ÿè£…ã•ã‚Œã¦ã„ã‚‹ã‹

### ãƒ‡ãƒ—ãƒ­ã‚¤å‰ãƒã‚§ãƒƒã‚¯
- [ ] **HTTPS**: æœ¬ç•ªç’°å¢ƒã§HTTPSå¼·åˆ¶ãŒæœ‰åŠ¹ã‹
- [ ] **ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒ˜ãƒƒãƒ€ãƒ¼**: é©åˆ‡ãªHTTPã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒ˜ãƒƒãƒ€ãƒ¼ãŒè¨­å®šã•ã‚Œã¦ã„ã‚‹ã‹
- [ ] **ä¾å­˜é–¢ä¿‚**: è„†å¼±æ€§ã®ã‚ã‚‹ä¾å­˜é–¢ä¿‚ãŒãªã„ã‹
- [ ] **ãƒ­ã‚°**: ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã‚¤ãƒ™ãƒ³ãƒˆãŒé©åˆ‡ã«ãƒ­ã‚°è¨˜éŒ²ã•ã‚Œã¦ã„ã‚‹ã‹
- [ ] **ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—**: ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã®æš—å·åŒ–ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ãŒè¨­å®šã•ã‚Œã¦ã„ã‚‹ã‹

### å®šæœŸç›£æŸ»
- [ ] **ã‚¢ã‚¯ã‚»ã‚¹æ¨©é™**: ä¸è¦ãªã‚¢ã‚¯ã‚»ã‚¹æ¨©é™ãŒãªã„ã‹
- [ ] **ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãƒãƒªã‚·ãƒ¼**: å¼·åŠ›ãªãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãƒãƒªã‚·ãƒ¼ãŒé©ç”¨ã•ã‚Œã¦ã„ã‚‹ã‹
- [ ] **ã‚»ãƒƒã‚·ãƒ§ãƒ³ç®¡ç†**: ã‚»ãƒƒã‚·ãƒ§ãƒ³ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆãŒé©åˆ‡ã«è¨­å®šã•ã‚Œã¦ã„ã‚‹ã‹
- [ ] **ç›£æŸ»ãƒ­ã‚°**: ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒ­ã‚°ãŒå®šæœŸçš„ã«ãƒ¬ãƒ“ãƒ¥ãƒ¼ã•ã‚Œã¦ã„ã‚‹ã‹

